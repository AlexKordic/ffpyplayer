To use:

You need to have a compiled ffmpeg and sdl, as well as their headers. The
ffmpeg version which has been tested is defined by the sha, _ffmpeg_git in __init__py.
It's assumed that the environment variables FFMPEG_ROOT and SDL_ROOT point
to a ffmpeg and sdl directories, respectively. In each directory there should be
three directories: include, lib, and bin. include and lib are needed for the
compiler compilation and linking stage, bin is needed for loading the shared
libraries at runtime if they are dynamically linked.
The lib dir contains the .a or .dll.a files, while bin contains the actual e.g. .dll files.
In the __init__.py file, we add the bin directory if it exists to the system path.
Both SDL1.2 and SDL2 have been tested and are supported.
We detect whether SDL2 is available by whether the include directory has a SDL2
directory.
Finally, you can specify which of the ffmpeg libraries are used by specifying
in the environment, e.g. CONFIG_AVFILTER=0. In particular, disabling avfilter
will save some space, but will also reduce the capabilities.

A example file, test.py, demonstrating the library is included. To use it,
provide a filename as the command line argument to test.py.
The FFPyPlayer constructor accepts many configuration arguments. To see what
is supported look in FFPyPlayer.__init__(). Most options have analogs in ffplay.c.
That class also provides the interface functions e.g. seeking, resizing etc.

-This is a port of ffplay.c. It accepts most files including network streams (rtsp, etc.), probably
webcams as well and outputs the video into a python callback. Audio is output
with SDL. It also supports text based subtitles which it outputs as text strings to
a callback. Alternatively you can show subtitles through filters. You can selectively exclude
ffmpeg libs when compiling, e.g. avfilter to reduce file size. Because it's
started with current ffmpeg source, we should be easily able to keep up with any
changes to ffmpeg by translating any changes to ffplay into cython.  So any bugs
we are having with the code is likely to also to affect ffmpeg and will probably
be reproducible with ffplay. So we could probably file bug reports with ffmpeg
and have them fix stuff which we can then replicate in our code...



------------------------------------------------------------------------------


TODO:

-Need to add documentation.
-Implement CONFIG_SDL
-The larger the frame size the higher the CPU. Currently, a copy occurs in cython
when queing a frame from the decoder. Another copy occurs when converting the
buffer into a bytes object. And finally another copy occurs in blit when the data
is copied to GPU. blit_buffer can be hacked to make it take a char*of the buffer
so that _NO_ copying of data occurrs. When testing, CPU did not go down much.
So the high CPU usage is because of large RGB buffers passed to GPU. YUV is smaller,
is that possible? http://stackoverflow.com/a/9337372. This is the biggest issue currently.
In any case, we can already get rid of the first copy from the end of the filter
chain by using ffmpeg ref counting. However, in that case we will have to deal with
buffers which are aligned to 8/16 bytes etc on a row by row basis. This thread
might explain how we can change kivy to be able to deal with this (maybe)
http://ffmpeg.org/pipermail/ffmpeg-devel/2013-May/143343.html. Also, if we can
add a parameter to blit_buffer which will cast to a char *, then the image data
will not have to be copied at all all!!! But that's not very pythonic, I suppose.

-gcc complains a lot but they are not actual issues, I believe. Go through them.
-Currently, it only supports text subtitles, bitmap subtitles are ignored.
You can also not yet visualize audio to video. If that is important it can be
made to work. The same with bitmap subtitles. Note, alternatively, you can use
the subtitles filter in the video filter chain. When we add a filter to handle
bitmap subtitle, most of the subtitle related code can be removed.
Do this by providing link between audio to video filters, and subtitle to video.
We can do this by making video stream dependent on subtitle or audio.

-need to call Py_DECREF to prevent memory leak in video_image_display is a cython bug, or feature?


--------------------------------

Things to watch out for when porting from c to cython:
In c the &,^,| operators are weaker than comparisons (<= etc.), in python it's reversed.
Macro function gets inlined in c, with variables names replaced to the current context
    variables. Pointers should be used in the macro replacement function to refer to
    the original variables. Use inline for them.
In c, a macro can work for arguments of type float, int, etc. simultanously because
    it just gets substituted. When porting a macro function you have to make a function
    for each input argument type combination that it's used on.
When you get cython errors about python objects it means you forgot to define some
    struct/variable which you used.
In c, if either numerator or denominator is a float, the result is also a float.
    In python, only if the denuminator is a float will the result be a float.
When converting loops from for (x=0;x<10;x++) to for x in range(10) make sure
    the code is not changing x in the loop since it won't work for python.
In cython you cannot use 0 instead of NULL, so for e.g. int *ptr = ...
    we have to check if ptr == NULL: instead of if not ptr:
When passing a string to c code which is kept, you have to keep python string in memory
