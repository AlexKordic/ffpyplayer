To use:
-Setup.py and __init__.py is configured for windows where the dlls are in /bin.
For unix they need to be modified before they can be used. A very recent ffmpeg
source as well as compiled dlls are included. Only tested with SDL 1.2, so that
should be used but we can get it to work with v2.

-The ffpyplayer __init__ func shows how it can be configured. It takes most of
the config paramtaters that ffmpeg's ffplay takes, including arbitrary video and
audio filters. If you don't use audio we should be able to ignore SDL entirly
since you can use either SDL or python threading elements.

-This started with a very recent ffmpeg source from which I ported ffplay into
cython. It accepts most files including network streams (rtsp, etc.), probably
webcams as well and outputs the video into a python callback. Audio is output
with SDL. It also supports text based subtitles which it outputs as text strings.
Alternatively you can show subtitles through filters. You can selectively excelude
ffmpeg libs when compiling, e.g. avfilter to reduce file size. Because it's
started with current ffmpeg source, we should be easily able to keep up with any
changes to ffmpeg by translating any changes to ffplay into cython.  So any bugs
we are having with the code is likely to also to affect ffmpeg and will probably
be reproducible with ffplay. So we could probably file bug reports with ffmpeg
and have them fix stuff which we can then replicate in our code...

-I'd consider the current version alpha, because style and organization can
probably be improved. Also, it lacks docs. But the library itself, excluding the
test.py example should be pretty stable. There are still notes and old commented
code sprinkled around that needs to be removed once the library is satisfiable.

TODO:

-Need to add documentation.
-Need to make proper setup.y and __init__.py.
-The larger the frame size the higher the CPU. Currently, a copy occurs in cython
when queing a frame from the decoder. Another copy occurs when converting the
buffer into a bytes object. And finally another copy occurs in blit when the data
is copied to GPU. blit_buffer can be hacked to make it take a char*of the buffer
so that _NO_ copying of data occurrs. When testing, CPU did not go down much.
So the high CPU usage is because of large RGB buffers passed to GPU. YUV is smaller,
is that possible? http://stackoverflow.com/a/9337372. This is the biggest issue currently.
In any case, we can already get rid of the first copy from the end of the filter
chain by using ffmpeg ref counting. However, in that case we will have to deal with
buffers which are aligned to 8/16 bytes etc on a row by row basis. This thread
might explain how we can change kivy to be able to deal with this (maybe)
http://ffmpeg.org/pipermail/ffmpeg-devel/2013-May/143343.html. Also, if we can
add a parameter to blit_buffer which will cast to a char *, then the image data
will not have to be copied at all all!!! But that's not very pythonic, I suppose.

-Implement opt_default() so that we can set any user options using av_dict in generic way
-provide full cross format image conversion libs using swsscale
-gcc complains a lot but they are not actual issues, I believe. Go through them.
-Currently, it only supports text subtitles, bitmap subtitles are ignored.
You can also not yet visualize audio to video. If that is important it can be
made to work. The same with bitmap subtitles. Note, alternatively, you can use
the subtitles filter in the video filter chain. When we add a filter to handle
bitmap subtitle, most of the subtitle related code can be removed.
Do this by providing link between audio to video filters, and subtitle to video.
We can do this by making video stream dependent on subtitle or audio.


need to call Py_DECREF to prevent memory leak in video_image_display is a cython bug, or feature?


--------------------------------

Things to watch out for when porting from c to cython:
In c the &,^,| operators are weaker than comparisons (<= etc.), in python it's reversed.
Macro function gets inlined in c, with variables names replaced to the current context
    variables. Pointers should be used in the macro replacement function to refer to
    the original variables. Use inline for them.
In c, a macro can work for arguments of type float, int, etc. simultanously because
    it just gets substituted. When porting a macro function you have to make a function
    for each input argument type combination that it's used on.
When you get cython errors about python objects it means you forgot to define some
    struct/variable which you used.
In c, if either numerator or denominator is a float, the result is also a float.
    In python, only if the denuminator is a float will the result be a float.
When converting loops from for (x=0;x<10;x++) to for x in range(10) make sure
    the code is not changing x in the loop since it won't work for python.
In cython you cannot use 0 instead of NULL, so for e.g. int *ptr = ...
    we have to check if ptr == NULL: instead of if not ptr:
When passing a string to c code which is kept, you have to keep python string in memory
